# 사용한 기술, 활용한 라이브러리에 대한 설명, 사용이유 등
- presentation layer
  - Material3 for Compose
    - Material Design 3 가이드라인을 따르는 UI 컴포넌트를 제공합니다.
    - (개인적으로는) 이렇게 디자인이 없을 때, 적은 노력으로도 구글의 UI/UX 가이드라인에 맞추어 일정수준 이상의 UI를 구성할 수 있어서 선호합니다.
      - (그러나 실무에서 디자인 요구사항을 맞출때는 Material3 컴포넌트 내부에 (minimum padding 같은) 제약이 있을 때가 많아, 대부분 직접 구현합니다.)
    - 커스텀 테마 적용시 컴포넌트 내부적으로 들어간 디폴트 컬러나 텍스트 스타일의 일관성 유지에 주의해야합니다.
  - Coil for Compose
    - Kotlin Coroutine 기반으로 구현한 안드로이드를 위한 이미지 로딩 라이브러리입니다.
    - Glide가 Java기반이고 Coil이 Kotlin기반인 것도 한 몫합니다. Coil이 Kotlin 친화적인 것은 물론이고, Java 코드를 Kotlin 기반 프로젝트에서 사용할 때는 platform type 때문에 주의해야합니다.
    - 그리고 이 프로젝트는 Coroutine과 OkHttp를 사용하고 있어서 Glide보다 적은 양의 메서드 수를 가져서 Glide보다 가볍다는 점에서 선택했습니다.
    - (사소하게는) Glide for Compose 는 아직도 beta이고 Coil이 더 활발하게 개발되고 있어서 안정적이라 생각합니다.
    - 다만, Glide에는 있고 Coil에는 없는 기능이 있지는 않은지(ex. thumbnail image / full image 로드) 신중하게 확인하고 Coil을 선택해야할 것입니다.
  - AAC ViewModel (이하 ViewModel)
    - ViewModel은 Android의 수명 주기를 고려하여 UI 관련 데이터를 저장하고 관리하는 클래스입니다.
    - 화면 회전이나 테마 변경, 언어 변경같은 같은 구성 변경이 발생해도 데이터를 유지할 수 있어서 UI 상태관리에 용이합니다. 
    - 또한 viewModelScope 같은 ViewModel의 생명주기를 따르는 CoroutineScope를 사용할 수 있어서 비동기 작업을 쉽게 처리할 수 있어서 사용했습니다.
    - ViewModel은 Activity/Fragment 보다 생명주기가 길기 때문에 ViewModel이 Activity나 Fragment의 참조를 가지면 메모리 누수를 일으킬 수 있어 주의해야합니다.
  - Jetpack Navigation
    - Jetpack Navigation은 Android 앱에서 화면 간 이동을 단순화하고 일관된 방식으로 관리할 수 있게 해주는 라이브러리입니다.
    - 거대한 화면이동 그래프를 직접 구현하면 생길 수많은 보일러플레이트 코드를 줄일 수 있어서 사용했습니다.  
    - 해당 프로젝트에선 Compose를 통합한 'androidx.navigation:navigation-compose' 라이브러리를 사용했습니다.
    - Compose 에선 특히 owner 로 ViewModelStoreOwner 구현체로 ViewModel을 사용하는지 주의해야합니다. 
    - 그렇지 않으면 새로운 특정화면에서 뒤로갔다가 다시 진입해도 owner가 같아서 의도치 않게 이전에 생성된 ViewModel을 다시 사용하는 경우가 발생할 수 있습니다. (자세한 내용은 질의 섹션에서 다룹니다.)  
  - Hilt Navigation Compose
    - Hilt Navigation Compose는 Jetpack Navigation과 Hilt를 통합하여 Compose에서 ViewModel을 사용할 수 있게 해주는 라이브러리입니다.
    - Navigation 백스택 엔트리에 맞춰 ViewModel의 범위를 관리해주기 위해 사용했습니다.
    - 이 역시 owner에 주의해야합니다. (자세한 내용은 질의 섹션에서 다룹니다.)
  - 기타 의존성
    - androidx.compose.ui
      - Jetpack Compose의 기본 UI 구성 요소를 제공하는 라이브러리입니다. 
      - 레이아웃, 그리기, 입력 처리와 같은 기본 UI 기능을 포함하여 필수적으로 추가하였습니다.
    - androidx.compose.ui.graphics
      - Jetpack Compose에서 그래픽 관련 기능을 제공하는 라이브러리입니다. 
      - 색상같은 그래픽 요소를 다뤄서 필수적으로 추가하였습니다.
    - androidx.activity.ktx
      - Activity와 관련된 작업을 Kotlin 확장 함수를 통해 더 간결하게 만듭니다.
      - ComponentActivity.enableEdgeToEdge()를 사용하여 따로 분기하지 않고 전체 화면 설정을 하기위해 사용했습니다.
    - androidx.ui.tooling.preview
      - Compose UI 개발을 위한 도구와 미리보기 기능을 제공합니다.
      - 기존 View 시스템에서 xml 의 미리보기 처럼 협업자에게 어떤 UI인지 직관적으로 보여줄 수 있어서 사용했습니다.
      - 미리보기 성능이 실제 디바이스와 다를 수 있으므로, 실제 디바이스에서 최종 테스트를 해봐야합니다.
- data layer
    - Retrofit2
      - 안드로이드 앱 개발에서 널리 사용되는 REST API 통신 라이브러리입니다.
      - 어노테이션을 사용하여 HTTP 메서드와 파라미터를 쉽게 정의할 수 있고 Coroutine과 함께 비동기 처리도 간편하게 할 수 있어 사용했습니다.
      - 다양한 Converter를 지원한다는 점도 있습니다.
      - 앱 난독화 시 Retrofit 관련 클래스가 제대로 동작하도록 ProGuard 규칙 설정에 주의해야합니다. 그렇지 않으면 JSON을 파싱하는 과정에서 예외가 발생합니다.
    - OkHttp3 logging interceptor
      - OkHttp 클라이언트의 HTTP 요청 및 응답을 로깅하는 인터셉터입니다. 
      - 이를 통해 네트워크 통신의 디버깅과 모니터링을 용이하게 하기위해 사용했습니다.
    - Kotlin Serialization for Retrofit JSON converter
      - Retrofit2에서 JSON을 파싱하기 위한 Converter 중 하나입니다.
      - Kotlin 친화적인 라이브러리로, Kotlin의 Data Class와 함께 사용하기 용이합니다.
      - 컴파일 타임에 직렬화 코드를 생성하므로 런타임 오류를 줄일 수 있습니다.
      - 같은 맥락에서 런타임에 reflection을 사용하지 않으니 더 나은 런타임 성능을 기대하고 사용했습니다.
      - 그리고 디폴트 값을 지원하고 ignoreUnknownKeys 같은 옵션도 지원하여 편리합니다.
      - 서버에서 예상치 못한 데이터 형식을 반환할 때를 예상하고 옵션 설정에 주의해야합니다.
      - 또한 converter 와 kotlinx-serialization-json 의 버전호환에 주의해야합니다.
    - Room
      - SQLite 데이터베이스를 더 쉽게 사용할 수 있게 추상화 레이어를 제공하는 라이브러리입니다.
      - 기본적으로 컴파일 타임에 쿼리 검사를 제공하여 런타임 오류를 줄이고, Coroutine 으로 비동기 작업하고, Flow를 통해 데이터베이스 변경을 관찰하기 위해 사용했습니다.
      - 복잡한 쿼리의 경우 성능 최적화에 주의해야하고 원자적으로 수행해야할 때는 Transaction을 적절히 사용해야 데이터 불일치가 발생하지 않습니다.
- domain layer
  - javax.inject
    - Java의 DI를 위한 표준 어노테이션을 제공하는 패키지입니다.
    - domain 레이어에서 안드로이드 의존성 없이 DI를 사용하기 위해 사용했습니다.
  - kotlinx-coroutines-core
    - Kotlin 언어의 코루틴을 지원하기 위한 핵심 라이브러리입니다.
    - domain 레이어에서 비동기 작업 시 안드로이드 의존성 없이 Coroutine을 사용하기 위해 사용했습니다.
- common
  - Jetpack Paging3
    - 안드로이드 앱에서 대량의 데이터를 효율적으로 로드하고 표시하기 위한 라이브러리입니다.
    - 페이지네이션 구현에서 발생하는 (스크롤에 따른 페이지 요청, 구성변경에도 데이터를 유지하기위한 캐싱 등의) 보일러플레이트 코드를 줄이고, 다른 중요한 코드에 집중하기 위해 사용했습니다.
    - Clean Architecture 기반 프로젝트에서는 구현방식을 고민해봐야합니다. PagingSource를 data레이어에 두고 domain레이어의 (플랫폼 의존적이지 않은)순수함을 타협할지, presentation 레이어에 두고 domain레이어를 순수하게 지킬지 고민해봐야합니다.   
    - 캐싱에 주의해야합니다. ViewModel을 유지하고 다른 화면을 다녀오거나 구성변경으로 인해 다시 구독할 때 캐싱해두지 않으면 불필요한 IO작업과 좋지 못한 UX가 발생할 수 있음에 주의해야합니다.
  - Dagger/Hilt
    - Dagger API를 Android에서 설치하고 설정하는 과정을 쉽게 해주는 오픈소스 래퍼 라이브러리입니다.
    - 안드로이드 구성요소에대해 컴포넌트 설정이 되어있어서 안드로이드 앱 개발할 때 보일러 플레이트 코드를 줄일 수 있어서 사용했습니다.
    - Koin과 비교했을 때 컴파일 타임에 의존성 그래프를 검증하여 런타임 오류를 줄일 수 있어 사용했습니다. 
  - Kotlin Coroutine/Flow
    - Kotlin Coroutine은 비동기 프로그래밍을 위한 Kotlin의 동시성 프레임워크입니다.
    - Flow는 Coroutine 기반의 비동기 데이터 스트림을 다루기 위한 API입니다.
    - Coroutine은 비동기 코드를 동기코드처럼 작성할 수 있어 직관적이고 가독성있는 코드를 작성할 수 있어서 사용했습니다.
    - Thread 를 직접 사용할 때와 비교했을 때 Context Switching 비용이 거의 없고 blocking 호출이 필요하지 않아 성능의 이점이 있어 사용했습니다.
    - 또한 다양한 라이브러리에서 Coroutine/Flow를 지원한다는 점도 있습니다.
    - Single Thread 가 아닐 때 critical section에 대한 동시성 이슈를 주의해야합니다.

    
# 질의
## Kotlin Coroutin/Flow
- Cold Flow, Hot Flow 란?
- State Flow, Shared Flow 란?
## Android ViewModel
- ViewModel owner 란?
- Compose Navigation + Hilt 조합에서 hiltViewModel()로 ViewModel Instance 가져올 때, owner를 어떻게 설정해야하는지 자세히 설명
## Android Paging3
- PagingSource와 **getRefreshkey** 함수의 파라미터와 리턴 값에 대해 자세히 설명
- PagingSource의 load 함수의 파라미터와 리턴 값에 대해 자세히 설명
